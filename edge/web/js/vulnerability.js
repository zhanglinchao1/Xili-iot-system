/*
 * è„†å¼±æ€§åˆ†ææ¨¡å—
 * è´Ÿè´£è„†å¼±æ€§è¯„ä¼°æ•°æ®çš„å±•ç¤ºå’Œäº¤äº’
 */

const Vulnerability = {
    // å½“å‰æ•°æ®
    currentData: null,
    
    // åˆå§‹åŒ–æ ‡å¿—ï¼Œé˜²æ­¢é‡å¤åˆå§‹åŒ–
    initialized: false,
    
    // åˆå§‹åŒ–
    init() {
        console.log('åˆå§‹åŒ–è„†å¼±æ€§åˆ†ææ¨¡å—');
        
        // ğŸ”¥ é˜²æ­¢é‡å¤åˆå§‹åŒ– - äº‹ä»¶ç›‘å¬å™¨åªç»‘å®šä¸€æ¬¡
        if (!this.initialized) {
            console.log('[Vulnerability] é¦–æ¬¡åˆå§‹åŒ–ï¼Œç»‘å®šäº‹ä»¶ç›‘å¬å™¨');
            this.bindEvents();
            this.initialized = true;
        } else {
            console.log('[Vulnerability] å·²åˆå§‹åŒ–ï¼Œè·³è¿‡äº‹ä»¶ç»‘å®š');
        }
        
        // æ¯æ¬¡åˆ‡æ¢é¡µé¢æ—¶éƒ½é‡æ–°åŠ è½½æ•°æ®
        this.loadData();
        this.startAutoRefresh();
    },
    
    // ç»‘å®šäº‹ä»¶
    bindEvents() {
        const refreshBtn = document.getElementById('refreshVulnerabilityBtn');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => this.loadData());
        }
    },
    
    // åŠ è½½æ•°æ®
    async loadData() {
        try {
            const response = await API.get('/api/v1/vulnerability/current');
            
            // æ£€æŸ¥å“åº”æ ¼å¼
            if (response && response.success === false) {
                // APIè¿”å›äº†é”™è¯¯ä¿¡æ¯
                console.warn('è„†å¼±æ€§è¯„ä¼°æœåŠ¡è¿”å›é”™è¯¯:', response);
                this.renderEmptyState();
                const message = response.message || 'æš‚æ— è¯„ä¼°æ•°æ®';
                UI.showToast(message, response.error === 'NO_DATA' ? 'warning' : 'error');
                
                // å¦‚æœæ˜¯NO_DATAé”™è¯¯ï¼Œ5ç§’åè‡ªåŠ¨é‡è¯•
                if (response.error === 'NO_DATA') {
                    setTimeout(() => {
                        console.log('è‡ªåŠ¨é‡è¯•åŠ è½½è„†å¼±æ€§æ•°æ®...');
                        this.loadData();
                    }, 5000);
                }
                return;
            }
            
            if (response && response.success && response.data) {
                this.currentData = response.data;
                this.renderAll();
            } else {
                console.error('åŠ è½½è„†å¼±æ€§æ•°æ®å¤±è´¥: å“åº”æ ¼å¼ä¸æ­£ç¡®', response);
                this.renderEmptyState();
                UI.showToast('æ•°æ®æ ¼å¼é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•', 'error');
            }
        } catch (error) {
            console.error('åŠ è½½è„†å¼±æ€§æ•°æ®å‡ºé”™:', error);
            this.renderEmptyState();
            
            // æ ¹æ®é”™è¯¯ç±»å‹æ˜¾ç¤ºä¸åŒçš„æç¤º
            let errorMessage = 'åŠ è½½æ•°æ®å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
            if (error.message && error.message.includes('Failed to fetch')) {
                errorMessage = 'æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥æœåŠ¡æ˜¯å¦æ­£å¸¸è¿è¡Œ';
            } else if (error.message) {
                errorMessage = error.message;
            }
            
            UI.showToast(errorMessage, 'error');
        }
    },
    
    // æ¸²æŸ“æ‰€æœ‰å†…å®¹
    renderAll() {
        if (!this.currentData) return;
        
        this.renderOverallScore();
        this.renderDimensionScores();
        this.renderMetrics();
        this.renderVulnerabilities();
    },
    
    // æ¸²æŸ“ç»¼åˆè¯„åˆ†
    renderOverallScore() {
        const { overall_score, risk_level } = this.currentData;
        
        // æ›´æ–°è¯„åˆ†æ•°å€¼
        const scoreValue = document.getElementById('overallScoreValue');
        if (scoreValue) {
            scoreValue.textContent = overall_score ? overall_score.toFixed(1) : '--';
        }
        
        // æ›´æ–°è¯„åˆ†åœ†ç¯é¢œè‰²
        const scoreCircle = document.getElementById('overallScoreCircle');
        if (scoreCircle) {
            scoreCircle.className = 'score-circle ' + this.getRiskClass(risk_level);
        }
        
        // æ›´æ–°é£é™©ç­‰çº§
        const riskBadge = document.getElementById('riskLevelBadge');
        const riskText = document.getElementById('riskLevelText');
        if (riskBadge && riskText) {
            riskBadge.className = 'risk-level-badge ' + this.getRiskClass(risk_level);
            riskText.textContent = this.getRiskLevelText(risk_level);
        }
    },
    
    // æ¸²æŸ“å„ç»´åº¦è¯„åˆ†
    renderDimensionScores() {
        const { license_compliance_score, communication_score, config_security_score, data_anomaly_score } = this.currentData;

        // è®¸å¯è¯åˆè§„æ€§è¯„åˆ†
        const licenseScore = document.getElementById('licenseScore');
        if (licenseScore) {
            licenseScore.textContent = license_compliance_score ? license_compliance_score.toFixed(1) : '--';
        }

        // é€šä¿¡å¼‚å¸¸è¯„åˆ†
        const commScore = document.getElementById('communicationScore');
        if (commScore) {
            commScore.textContent = communication_score ? communication_score.toFixed(1) : '--';
        }

        // é…ç½®å®‰å…¨è¯„åˆ†
        const configScore = document.getElementById('configScore');
        if (configScore) {
            configScore.textContent = config_security_score ? config_security_score.toFixed(1) : '--';
        }

        // æ•°æ®å¼‚å¸¸è¯„åˆ†
        const dataScore = document.getElementById('dataScore');
        if (dataScore) {
            dataScore.textContent = data_anomaly_score ? data_anomaly_score.toFixed(1) : '--';
        }
    },
    
    // æ¸²æŸ“ä¼ è¾“æŒ‡æ ‡
    renderMetrics() {
        if (!this.currentData || !this.currentData.transmission_metrics) {
            this.renderEmptyMetrics();
            return;
        }
        
        const metrics = this.currentData.transmission_metrics;
        
        // å¹³å‡å»¶è¿Ÿ
        const latency = document.getElementById('metricLatency');
        if (latency) {
            const value = metrics.latency_avg !== undefined && metrics.latency_avg !== null ? metrics.latency_avg.toFixed(2) : '--';
            latency.textContent = value + ' ms';
        }
        
        // ä¸¢åŒ…ç‡ï¼ˆå°†0-1è½¬æ¢ä¸ºç™¾åˆ†æ¯”ï¼‰
        const loss = document.getElementById('metricLoss');
        if (loss) {
            const value = metrics.packet_loss_rate !== undefined && metrics.packet_loss_rate !== null 
                ? (metrics.packet_loss_rate * 100).toFixed(2) 
                : '--';
            loss.textContent = value + ' %';
        }
        
        // ååé‡
        const throughput = document.getElementById('metricThroughput');
        if (throughput) {
            const value = metrics.throughput !== undefined && metrics.throughput !== null ? metrics.throughput.toFixed(2) : '--';
            throughput.textContent = value + ' Kbps';
        }
        
        // MQTTæˆåŠŸç‡ï¼ˆå°†0-1è½¬æ¢ä¸ºç™¾åˆ†æ¯”ï¼‰
        const mqttRate = document.getElementById('metricMQTT');
        if (mqttRate) {
            const value = metrics.mqtt_success_rate !== undefined && metrics.mqtt_success_rate !== null 
                ? (metrics.mqtt_success_rate * 100).toFixed(2) 
                : '--';
            mqttRate.textContent = value + ' %';
        }
        
        // é‡è¿æ¬¡æ•°
        const reconnect = document.getElementById('metricReconnect');
        if (reconnect) {
            const value = metrics.reconnection_count !== undefined && metrics.reconnection_count !== null 
                ? metrics.reconnection_count 
                : '--';
            reconnect.textContent = value;
        }
    },
    
    // æ¸²æŸ“ç©ºæŒ‡æ ‡
    renderEmptyMetrics() {
        const elements = [
            {id: 'metricLatency', text: '-- ms'},
            {id: 'metricLoss', text: '-- %'},
            {id: 'metricThroughput', text: '-- Kbps'},
            {id: 'metricMQTT', text: '-- %'},
            {id: 'metricReconnect', text: '--'}
        ];
        
        elements.forEach(elem => {
            const el = document.getElementById(elem.id);
            if (el) el.textContent = elem.text;
        });
    },
    
    // æ¸²æŸ“ç©ºçŠ¶æ€
    renderEmptyState() {
        // ç»¼åˆè¯„åˆ†
        const scoreValue = document.getElementById('overallScoreValue');
        if (scoreValue) scoreValue.textContent = '--';
        
        const riskText = document.getElementById('riskLevelText');
        if (riskText) riskText.textContent = 'æš‚æ— æ•°æ®';
        
        // å„ç»´åº¦è¯„åˆ† (å››ç»´åº¦)
        const licenseScore = document.getElementById('licenseScore');
        if (licenseScore) licenseScore.textContent = '--';

        const commScore = document.getElementById('communicationScore');
        if (commScore) commScore.textContent = '--';

        const configScore = document.getElementById('configScore');
        if (configScore) configScore.textContent = '--';

        const dataScore = document.getElementById('dataScore');
        if (dataScore) dataScore.textContent = '--';
        
        // ä¼ è¾“æŒ‡æ ‡
        this.renderEmptyMetrics();
        
        // æ¼æ´åˆ—è¡¨
        const container = document.getElementById('vulnerabilityList');
        if (container) {
            container.innerHTML = '<p style="text-align: center; color: #666;">æš‚æ— è¯„ä¼°æ•°æ®</p>';
        }
    },
    
    // æ¸²æŸ“æ¼æ´åˆ—è¡¨
    renderVulnerabilities() {
        const container = document.getElementById('vulnerabilityList');
        if (!container) return;
        
        const vulnerabilities = this.currentData.detected_vulnerabilities || [];
        
        if (vulnerabilities.length === 0) {
            container.innerHTML = '<p style="text-align: center; color: #666;">æš‚æ— æ£€æµ‹åˆ°çš„æ¼æ´</p>';
            return;
        }
        
        let html = '<table class="data-table"><thead><tr>';
        html += '<th>ç±»å‹</th><th>ä¸¥é‡ç¨‹åº¦</th><th>æè¿°</th><th>æ£€æµ‹æ—¶é—´</th><th>æ“ä½œ</th>';
        html += '</tr></thead><tbody>';
        
        vulnerabilities.forEach(vuln => {
            html += '<tr>';
            html += `<td><span class="badge">${this.getVulnTypeText(vuln.type)}</span></td>`;
            html += `<td><span class="severity-badge ${vuln.severity}">${this.getSeverityText(vuln.severity)}</span></td>`;
            html += `<td>${vuln.description}</td>`;
            html += `<td>${this.formatDate(vuln.detected_at)}</td>`;
            
            // åªå¯¹é…ç½®ç¯¡æ”¹ç±»æ¼æ´æ˜¾ç¤ºæ¶ˆé™¤æŒ‰é’®
            if (vuln.type === 'config_tampering') {
                html += `<td><button class="btn btn-sm btn-warning dismiss-btn" data-type="${vuln.type}">æ¶ˆé™¤</button></td>`;
            } else {
                html += '<td>--</td>';
            }
            
            html += '</tr>';
        });
        
        html += '</tbody></table>';
        container.innerHTML = html;
        
        // ä¸ºæ¶ˆé™¤æŒ‰é’®æ·»åŠ äº‹ä»¶ç›‘å¬
        container.querySelectorAll('.dismiss-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const vulnType = e.target.getAttribute('data-type');
                this.dismissVulnerability(vulnType);
            });
        });
    },
    
    // æ¶ˆé™¤æ¼æ´
    async dismissVulnerability(vulnType) {
        if (!confirm('ç¡®å®šè¦æ¶ˆé™¤æ­¤æ¼æ´è­¦å‘Šå—ï¼Ÿæ¶ˆé™¤å24å°æ—¶å†…ä¸ä¼šå†æ¬¡æç¤ºã€‚')) {
            return;
        }
        
        try {
            const response = await API.post('/api/v1/vulnerability/dismiss', {
                vulnerability_type: vulnType,
                reason: 'æµ‹è¯•ç¯å¢ƒæ­£å¸¸éƒ¨ç½²æ“ä½œ'
            });
            
            if (response && response.success) {
                UI.showToast('æ¼æ´å·²æ¶ˆé™¤ï¼Œæ­£åœ¨é‡æ–°è¯„ä¼°...', 'success');
                
                // ç­‰å¾…3ç§’åé‡æ–°åŠ è½½æ•°æ®
                setTimeout(() => {
                    this.loadData();
                }, 3000);
            } else {
                const message = response.message || 'æ¶ˆé™¤æ¼æ´å¤±è´¥';
                UI.showToast(message, 'error');
            }
        } catch (error) {
            console.error('æ¶ˆé™¤æ¼æ´å¤±è´¥:', error);
            UI.showToast('æ“ä½œå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', 'error');
        }
    },
    
    // è·å–é£é™©ç­‰çº§ç±»å
    getRiskClass(riskLevel) {
        const classMap = {
            'healthy': 'risk-healthy',
            'low': 'risk-low',
            'medium': 'risk-medium',
            'high': 'risk-high',
            'critical': 'risk-critical'
        };
        return classMap[riskLevel] || 'risk-unknown';
    },

    // è·å–é£é™©ç­‰çº§æ–‡æœ¬
    getRiskLevelText(riskLevel) {
        const textMap = {
            'healthy': 'å¥åº·çŠ¶æ€',
            'low': 'ä½é£é™©',
            'medium': 'ä¸­ç­‰é£é™©',
            'high': 'é«˜é£é™©',
            'critical': 'ä¸¥é‡é£é™©'
        };
        return textMap[riskLevel] || 'æœªçŸ¥é£é™©';
    },
    
    // è·å–æ¼æ´ç±»å‹æ–‡æœ¬
    getVulnTypeText(type) {
        const textMap = {
            'port_scan': 'ç«¯å£æ‰«æ',
            'frequency_spike': 'é¢‘ç‡çªå¢',
            'frequency_drop': 'é¢‘ç‡éª¤é™',
            'config_tampering': 'é…ç½®ç¯¡æ”¹',
            'storage_warning': 'å­˜å‚¨å‘Šè­¦',
            'disk_full': 'ç£ç›˜æ»¡'
        };
        return textMap[type] || type;
    },
    
    // è·å–ä¸¥é‡ç¨‹åº¦æ–‡æœ¬
    getSeverityText(severity) {
        const textMap = {
            'low': 'ä½',
            'medium': 'ä¸­',
            'high': 'é«˜',
            'critical': 'ä¸¥é‡'
        };
        return textMap[severity] || severity;
    },
    
    // æ ¼å¼åŒ–æ—¥æœŸ
    formatDate(dateStr) {
        if (!dateStr) return '--';
        const date = new Date(dateStr);
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    },
    
    // å¼€å§‹è‡ªåŠ¨åˆ·æ–°
    startAutoRefresh() {
        // æ¯30ç§’è‡ªåŠ¨åˆ·æ–°ä¸€æ¬¡
        this.refreshInterval = setInterval(() => {
            // åªåœ¨è„†å¼±æ€§åˆ†æé¡µé¢å¯è§æ—¶æ‰åˆ·æ–°
            const page = document.getElementById('vulnerabilityPage');
            if (page && !page.classList.contains('hidden')) {
                this.loadData();
            }
        }, 30000);
    },
    
    // åœæ­¢è‡ªåŠ¨åˆ·æ–°
    stopAutoRefresh() {
        if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
            this.refreshInterval = null;
        }
    },
    
    // é”€æ¯
    destroy() {
        this.stopAutoRefresh();
    }
};

