/*
 * 脆弱性评估服务
 * 负责协调各个评分模块和漏洞检测
 */
package vulnerability

import (
	"context"
	"database/sql"
	"encoding/json"
	"os"
	"sync"
	"time"

	"github.com/edge/storage-cabinet/internal/device"
	"github.com/edge/storage-cabinet/internal/license"
	"github.com/edge/storage-cabinet/pkg/models"
	"go.uber.org/zap"
)

// CloudSyncClient Cloud同步客户端接口
type CloudSyncClient interface {
	SyncVulnerabilityAssessment(report *models.EdgeVulnerabilityReport) error
}

// Service 脆弱性评估服务
type Service struct {
	logger         *zap.Logger
	db             *sql.DB
	config         VulnerabilityConfig
	deviceManager  *device.Manager
	licenseService *license.Service
	cabinetID      string // 储能柜ID

	// 评分模块 (四维度)
	licenseScorer *LicenseScorer // 新增: 许可证合规性评分器
	commScorer    *CommunicationScorer
	configScorer  *ConfigScorer
	dataScorer    *DataScorer
	detector      *Detector
	aggregator    *Aggregator

	// MQTT统计(可选)
	mqttStats MQTTStatsProvider

	// 流量上报（可选）
	trafficPublisher TrafficPublisher

	// Cloud同步客户端(可选)
	cloudSync CloudSyncClient

	// 运行状态
	ctx    context.Context
	cancel context.CancelFunc
	wg     sync.WaitGroup

	// 最后评估结果缓存
	lastAssessment   *models.EdgeVulnerabilityReport
	lastAssessmentMu sync.RWMutex
}

// MQTTStatsProvider MQTT统计数据提供者接口
type MQTTStatsProvider interface {
	GetAverageLatency() float64
	GetPacketLossRate() float64
	GetThroughput() float64
	GetSuccessRate() float64
	GetReconnectCount() int
}

// TrafficPublisher 流量发布接口
type TrafficPublisher interface {
	PublishReport(report *models.EdgeVulnerabilityReport) error
}

// VulnerabilityConfig 脆弱性评估配置
type VulnerabilityConfig struct {
	Enabled              bool
	AssessmentInterval   time.Duration
	ScoreChangeThreshold float64
	HistoryRetention     time.Duration

	Weights struct {
		Communication  float64
		ConfigSecurity float64
		DataAnomaly    float64
	}

	Communication struct {
		LatencyThresholdMs        float64
		PacketLossThreshold       float64
		ReconnectThresholdPerHour int
	}

	DataAnomaly struct {
		MissingRateThreshold    float64
		AbnormalValueThreshold  float64
		AlertFrequencyThreshold int
	}

	// 用于配置检查的参数
	MQTTBroker string
	ServerHost string
	LogLevel   string
}

// NewService 创建脆弱性评估服务实例
func NewService(
	cfg VulnerabilityConfig,
	db *sql.DB,
	deviceManager *device.Manager,
	licenseService *license.Service,
	logger *zap.Logger,
) *Service {
	// 获取CabinetID（优先从环境变量，其次使用默认值）
	// 注意：实际应从配置文件的cloud.cabinet_id传入，这里作为备用方案
	cabinetID := os.Getenv("CABINET_ID")
	if cabinetID == "" {
		cabinetID = "CABINET-001" // 默认值
	}

	ctx, cancel := context.WithCancel(context.Background())

	s := &Service{
		logger:         logger,
		db:             db,
		config:         cfg,
		deviceManager:  deviceManager,
		licenseService: licenseService,
		cabinetID:      cabinetID,
		ctx:            ctx,
		cancel:         cancel,
	}

	// 初始化各个评分模块 (四维度)
	s.licenseScorer = NewLicenseScorer(licenseService, logger) // 使用licenseService
	s.commScorer = NewCommunicationScorer(cfg, logger)
	s.configScorer = NewConfigScorer(cfg, licenseService, cfg.MQTTBroker, cfg.ServerHost, cfg.LogLevel, logger)
	s.dataScorer = NewDataScorer(cfg, db, logger)
	s.detector = NewDetector(cfg, db, logger)
	s.aggregator = NewAggregator(cfg, logger)

	return s
}

// SetMQTTStats 设置MQTT统计数据提供者
func (s *Service) SetMQTTStats(mqttStats MQTTStatsProvider) {
	s.mqttStats = mqttStats
}

// SetTrafficPublisher 设置流量发布器
func (s *Service) SetTrafficPublisher(publisher TrafficPublisher) {
	s.trafficPublisher = publisher
}

// SetCloudSync 设置Cloud同步客户端
func (s *Service) SetCloudSync(cloudSync CloudSyncClient) {
	s.cloudSync = cloudSync
	s.logger.Info("Cloud同步客户端已设置")
}

// Start 启动脆弱性评估服务
func (s *Service) Start(ctx context.Context) error {
	if !s.config.Enabled {
		s.logger.Info("脆弱性评估服务未启用")
		return nil
	}

	s.logger.Info("启动脆弱性评估服务",
		zap.Duration("interval", s.config.AssessmentInterval),
	)

	// 启动后台评估任务
	s.wg.Add(1)
	go s.assessmentLoop()

	// 启动清理任务
	s.wg.Add(1)
	go s.cleanupLoop()

	return nil
}

// Stop 停止脆弱性评估服务
func (s *Service) Stop() error {
	s.logger.Info("停止脆弱性评估服务")
	s.cancel()
	s.wg.Wait()
	return nil
}

// assessmentLoop 评估循环
func (s *Service) assessmentLoop() {
	defer s.wg.Done()

	ticker := time.NewTicker(s.config.AssessmentInterval)
	defer ticker.Stop()

	// 立即执行一次评估
	s.performAssessment()

	for {
		select {
		case <-s.ctx.Done():
			return
		case <-ticker.C:
			s.performAssessment()
		}
	}
}

// performAssessment 执行评估
func (s *Service) performAssessment() {
	s.logger.Debug("开始执行脆弱性评估")

	// 使用Service中的cabinetID
	cabinetID := s.cabinetID

	// 1. 收集传输指标(优先使用MQTT统计)
	var metrics *models.TransmissionMetrics
	if s.mqttStats != nil {
		// 使用MQTT实际统计数据
		metrics = &models.TransmissionMetrics{
			LatencyAvg:        s.mqttStats.GetAverageLatency(),
			PacketLossRate:    s.mqttStats.GetPacketLossRate(),
			Throughput:        s.mqttStats.GetThroughput(),
			MQTTSuccessRate:   s.mqttStats.GetSuccessRate(),
			ReconnectionCount: s.mqttStats.GetReconnectCount(),
		}
	} else {
		// 降级:使用通信评分器自带的统计
		metrics = s.commScorer.CollectMetrics()
	}

	// 2. 计算各维度评分 (四维度)
	licenseScore := s.licenseScorer.CalculateScore() // 新增: 许可证评分
	commScore := s.commScorer.CalculateScore(metrics)
	configScore := s.configScorer.CalculateScore()
	dataScore := s.dataScorer.CalculateScore(cabinetID)

	// 3. 检测漏洞
	vulnerabilities := s.detector.DetectVulnerabilities(cabinetID)

	// 4. 过滤已消除的漏洞
	vulnerabilities = s.filterDismissedVulnerabilities(vulnerabilities)

	// 5. 获取配置检查结果
	configChecks := s.configScorer.GetCheckResults()

	// 6. 聚合评分 (四维度)
	report := s.aggregator.AggregateScores(
		cabinetID,
		licenseScore, // 新增参数
		commScore,
		configScore,
		dataScore,
		metrics,
		vulnerabilities,
		configChecks,
	)

	if s.trafficPublisher != nil {
		if err := s.trafficPublisher.PublishReport(report); err != nil {
			s.logger.Warn("发布实时流量失败", zap.Error(err))
		}
	}

	// 5. 保存评估结果
	if err := s.saveAssessment(report); err != nil {
		s.logger.Error("保存评估结果失败", zap.Error(err))
		return
	}

	// 6. 检查是否为首次评估
	s.lastAssessmentMu.RLock()
	isFirstAssessment := s.lastAssessment == nil
	s.lastAssessmentMu.RUnlock()

	// 7. 检查评分变化(会触发Cloud同步)
	s.checkScoreChange(report)

	// 8. 如果是首次评估,也需要同步到Cloud
	if isFirstAssessment && s.cloudSync != nil {
		go func(r *models.EdgeVulnerabilityReport) {
			if err := s.cloudSync.SyncVulnerabilityAssessment(r); err != nil {
				s.logger.Error("首次评估同步到Cloud失败",
					zap.Error(err),
					zap.Int64("assessment_id", r.ID),
				)
			} else {
				s.logger.Info("首次评估已同步到Cloud",
					zap.Int64("assessment_id", r.ID),
					zap.Float64("overall_score", r.OverallScore),
				)
			}
		}(report)
	}

	// 9. 更新缓存
	s.lastAssessmentMu.Lock()
	s.lastAssessment = report
	s.lastAssessmentMu.Unlock()

	s.logger.Info("脆弱性评估完成",
		zap.Float64("overall_score", report.OverallScore),
		zap.String("risk_level", report.RiskLevel),
		zap.Int("vulnerabilities", len(report.DetectedVulnerabilities)),
	)
}

// saveAssessment 保存评估结果到数据库
func (s *Service) saveAssessment(report *models.EdgeVulnerabilityReport) error {
	// 序列化JSON字段
	metricsJSON, _ := json.Marshal(report.TransmissionMetrics)
	featuresJSON, _ := json.Marshal(report.TrafficFeatures)
	checksJSON, _ := json.Marshal(report.ConfigChecks)
	vulnJSON, _ := json.Marshal(report.DetectedVulnerabilities)

	query := `
		INSERT INTO vulnerability_assessments (
			cabinet_id, timestamp, license_compliance_score, communication_score,
			config_security_score, data_anomaly_score, overall_score, risk_level,
			transmission_metrics, traffic_features, config_checks,
			detected_vulnerabilities, synced
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
	`

	result, err := s.db.Exec(query,
		report.CabinetID,
		report.Timestamp,
		report.LicenseComplianceScore, // 新增字段
		report.CommunicationScore,
		report.ConfigSecurityScore,
		report.DataAnomalyScore,
		report.OverallScore,
		report.RiskLevel,
		string(metricsJSON),
		string(featuresJSON),
		string(checksJSON),
		string(vulnJSON),
		false, // synced
	)

	if err != nil {
		return err
	}

	// 获取插入的ID并设置到report中
	id, err := result.LastInsertId()
	if err != nil {
		s.logger.Warn("获取插入ID失败", zap.Error(err))
	} else {
		report.ID = id
	}

	return nil
}

// checkScoreChange 检查评分变化
func (s *Service) checkScoreChange(newReport *models.EdgeVulnerabilityReport) {
	s.lastAssessmentMu.RLock()
	lastReport := s.lastAssessment
	s.lastAssessmentMu.RUnlock()

	if lastReport == nil {
		return
	}

	// 计算评分变化
	scoreDiff := newReport.OverallScore - lastReport.OverallScore
	if scoreDiff < 0 {
		scoreDiff = -scoreDiff
	}

	// 风险等级是否变化
	riskLevelChanged := newReport.RiskLevel != lastReport.RiskLevel

	// 判断是否需要上报
	shouldReport := scoreDiff >= s.config.ScoreChangeThreshold || riskLevelChanged

	if shouldReport {
		s.logger.Info("检测到评分变化，触发上报",
			zap.Float64("score_diff", scoreDiff),
			zap.Bool("risk_level_changed", riskLevelChanged),
			zap.String("old_risk", lastReport.RiskLevel),
			zap.String("new_risk", newReport.RiskLevel),
		)

		// 触发Cloud端上报
		if s.cloudSync != nil {
			go func(report *models.EdgeVulnerabilityReport) {
				if err := s.cloudSync.SyncVulnerabilityAssessment(report); err != nil {
					s.logger.Error("同步脆弱性评估到Cloud失败",
						zap.Error(err),
						zap.Int64("assessment_id", report.ID),
					)
				}
			}(newReport)
		}
	}
}

// cleanupLoop 清理历史数据循环
func (s *Service) cleanupLoop() {
	defer s.wg.Done()

	ticker := time.NewTicker(24 * time.Hour) // 每天清理一次
	defer ticker.Stop()

	for {
		select {
		case <-s.ctx.Done():
			return
		case <-ticker.C:
			s.cleanupOldData()
		}
	}
}

// cleanupOldData 清理过期数据
func (s *Service) cleanupOldData() {
	cutoffTime := time.Now().Add(-s.config.HistoryRetention)

	// 清理评估记录
	query := `DELETE FROM vulnerability_assessments WHERE timestamp < ?`
	result, err := s.db.Exec(query, cutoffTime)
	if err != nil {
		s.logger.Error("清理评估记录失败", zap.Error(err))
		return
	}

	affected, _ := result.RowsAffected()
	s.logger.Info("清理过期评估记录",
		zap.Int64("deleted", affected),
		zap.Time("cutoff_time", cutoffTime),
	)

	// 清理传输指标记录
	query = `DELETE FROM transmission_metrics WHERE timestamp < ?`
	result, err = s.db.Exec(query, cutoffTime)
	if err != nil {
		s.logger.Error("清理传输指标失败", zap.Error(err))
		return
	}

	affected, _ = result.RowsAffected()
	s.logger.Info("清理过期传输指标",
		zap.Int64("deleted", affected),
	)
}

// GetCurrentAssessment 获取当前评估结果
func (s *Service) GetCurrentAssessment() *models.EdgeVulnerabilityReport {
	s.lastAssessmentMu.RLock()
	defer s.lastAssessmentMu.RUnlock()
	return s.lastAssessment
}

// DismissVulnerability 消除指定漏洞
func (s *Service) DismissVulnerability(vulnType string, reason string) error {
	// 默认消除24小时
	expiresAt := time.Now().Add(24 * time.Hour)

	query := `
		INSERT INTO dismissed_vulnerabilities (vulnerability_type, reason, expires_at)
		VALUES (?, ?, ?)
	`

	_, err := s.db.Exec(query, vulnType, reason, expiresAt)
	if err != nil {
		s.logger.Error("消除漏洞失败",
			zap.String("vuln_type", vulnType),
			zap.Error(err))
		return err
	}

	s.logger.Info("漏洞已消除",
		zap.String("vuln_type", vulnType),
		zap.String("reason", reason),
		zap.Time("expires_at", expiresAt))

	return nil
}

// GetDismissedVulnerabilities 获取已消除的漏洞列表（未过期）
func (s *Service) GetDismissedVulnerabilities() ([]string, error) {
	query := `
		SELECT vulnerability_type 
		FROM dismissed_vulnerabilities
		WHERE expires_at IS NULL OR expires_at > datetime('now')
		GROUP BY vulnerability_type
	`

	rows, err := s.db.Query(query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	dismissed := []string{}
	for rows.Next() {
		var vulnType string
		if err := rows.Scan(&vulnType); err != nil {
			continue
		}
		dismissed = append(dismissed, vulnType)
	}

	return dismissed, nil
}

// filterDismissedVulnerabilities 过滤已消除的漏洞
func (s *Service) filterDismissedVulnerabilities(vulnerabilities []models.VulnerabilityEvent) []models.VulnerabilityEvent {
	dismissed, err := s.GetDismissedVulnerabilities()
	if err != nil {
		s.logger.Warn("获取已消除漏洞列表失败", zap.Error(err))
		return vulnerabilities
	}

	if len(dismissed) == 0 {
		return vulnerabilities
	}

	// 创建已消除漏洞类型的map
	dismissedMap := make(map[string]bool)
	for _, vulnType := range dismissed {
		dismissedMap[vulnType] = true
	}

	// 过滤掉已消除的漏洞
	filtered := []models.VulnerabilityEvent{}
	for _, vuln := range vulnerabilities {
		if !dismissedMap[vuln.Type] {
			filtered = append(filtered, vuln)
		}
	}

	if len(filtered) < len(vulnerabilities) {
		s.logger.Info("已过滤消除的漏洞",
			zap.Int("original_count", len(vulnerabilities)),
			zap.Int("filtered_count", len(filtered)))
	}

	return filtered
}

// GetAssessmentHistory 获取评估历史
func (s *Service) GetAssessmentHistory(cabinetID string, startTime, endTime time.Time, limit int) ([]models.VulnerabilityAssessment, error) {
	if limit <= 0 || limit > 1000 {
		limit = 100
	}

	query := `
		SELECT id, cabinet_id, timestamp, license_compliance_score, communication_score,
			config_security_score, data_anomaly_score, overall_score, risk_level,
			transmission_metrics, traffic_features, config_checks,
			detected_vulnerabilities, synced, synced_at
		FROM vulnerability_assessments
		WHERE cabinet_id = ? AND timestamp >= ? AND timestamp <= ?
		ORDER BY timestamp DESC
		LIMIT ?
	`

	rows, err := s.db.Query(query, cabinetID, startTime, endTime, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var assessments []models.VulnerabilityAssessment
	for rows.Next() {
		var a models.VulnerabilityAssessment
		err := rows.Scan(
			&a.ID, &a.CabinetID, &a.Timestamp,
			&a.LicenseComplianceScore, // 新增字段
			&a.CommunicationScore, &a.ConfigSecurityScore, &a.DataAnomalyScore,
			&a.OverallScore, &a.RiskLevel,
			&a.TransmissionMetricsJSON, &a.TrafficFeaturesJSON,
			&a.ConfigChecksJSON, &a.DetectedVulnJSON,
			&a.Synced, &a.SyncedAt,
		)
		if err != nil {
			return nil, err
		}
		assessments = append(assessments, a)
	}

	return assessments, rows.Err()
}

// TriggerAssessment 手动触发评估
func (s *Service) TriggerAssessment() {
	s.logger.Info("手动触发脆弱性评估")
	go s.performAssessment()
}
