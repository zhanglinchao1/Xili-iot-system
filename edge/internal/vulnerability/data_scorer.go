/*
 * 数据异常评分模块
 * 基于传感器数据质量计算评分
 */
package vulnerability

import (
	"database/sql"
	"math"
	"time"

	"go.uber.org/zap"
)

// DataScorer 数据异常评分器
type DataScorer struct {
	logger *zap.Logger
	config VulnerabilityConfig
	db     *sql.DB
}

// DataQualityMetrics 数据质量指标
type DataQualityMetrics struct {
	TotalExpected   int     // 预期数据条数
	TotalReceived   int     // 实际收到数据条数
	MissingRate     float64 // 缺失率
	AbnormalCount   int     // 异常值数量
	AbnormalRate    float64 // 异常值比例
	AlertCount      int     // 告警数量
	ContinuityScore float64 // 连续性评分
}

// NewDataScorer 创建数据异常评分器
func NewDataScorer(cfg VulnerabilityConfig, db *sql.DB, logger *zap.Logger) *DataScorer {
	return &DataScorer{
		logger: logger,
		config: cfg,
		db:     db,
	}
}

// CalculateScore 计算数据异常评分
func (s *DataScorer) CalculateScore(cabinetID string) float64 {
	// 获取最近1小时的数据质量指标
	metrics := s.collectDataMetrics(cabinetID, 1*time.Hour)

	// 检查数据有效性
	hasData := metrics.TotalReceived > 0
	
	// 如果没有数据，给予基础分数（85分），避免因数据不足导致评分过低
	if !hasData {
		s.logger.Warn("数据评分：无有效数据，使用默认分数85分",
			zap.Int("total_expected", metrics.TotalExpected),
			zap.Int("total_received", metrics.TotalReceived))
		// 系统刚启动或测试阶段，给予较高默认分
		return 95.0
	}

	baseScore := 100.0

	// 1. 缺失率扣分 (采用更宽松的评分策略，适应实际运行环境)
	missingThreshold := s.config.DataAnomaly.MissingRateThreshold
	if missingThreshold <= 0 {
		missingThreshold = 0.15 // 提高容忍度：10%→15%
	}

	if metrics.MissingRate > missingThreshold {
		if metrics.MissingRate > 0.40 {
			baseScore -= 10 // 降低扣分：30→20，40%以上才重扣
		} else {
			// 线性插值：从阈值到40%，扣分从3到20
			penalty := 1 + (metrics.MissingRate-missingThreshold)/(0.40-missingThreshold)*17
			baseScore -= penalty
		}
	}

	// 2. 异常值比例扣分 (异常值 < 阈值: 不扣分, 阈值-30%: 线性扣分5-25分, >30%: 扣35分)
	abnormalThreshold := s.config.DataAnomaly.AbnormalValueThreshold
	if abnormalThreshold <= 0 {
		abnormalThreshold = 0.15 // 默认15%
	}

	if metrics.AbnormalRate > abnormalThreshold {
		if metrics.AbnormalRate > 0.30 {
			baseScore -= 35 // 降低：40 → 35
		} else {
			// 线性插值：从阈值到30%，扣分从5到35
			penalty := 5 + (metrics.AbnormalRate-abnormalThreshold)/(0.30-abnormalThreshold)*30
			baseScore -= penalty
		}
	}

	// 3. 告警频率扣分 (告警数 < 阈值: 不扣分, 阈值-30: 线性扣分3-12分, >30: 扣15分)
	alertThreshold := s.config.DataAnomaly.AlertFrequencyThreshold
	if alertThreshold <= 0 {
		alertThreshold = 20 // 默认20
	}

	if metrics.AlertCount > alertThreshold {
		if metrics.AlertCount > 30 {
			baseScore -= 15 // 降低：20 → 15
		} else {
			// 线性插值：从阈值到30，扣分从3到15
			penalty := 3 + float64(metrics.AlertCount-alertThreshold)/float64(30-alertThreshold)*12
			baseScore -= penalty
		}
	}

	// 4. 数据连续性扣分 (进一步降低影响，连续性不是核心指标)
	baseScore -= (1.0 - metrics.ContinuityScore) * 2 // 降低：8 → 5

	// 确保评分在合理范围内
	if baseScore < 0 {
		baseScore = 0
	}
	if baseScore > 100 {
		baseScore = 100
	}

	// 使用完整的100分制评分（移除人为限制）
	// 数据质量好应该获得高分
	finalScore := baseScore * 1.0 // 95%权重，稍作保留

	s.logger.Info("数据异常评分计算完成",
		zap.Bool("has_data", hasData),
		zap.Int("total_expected", metrics.TotalExpected),
		zap.Int("total_received", metrics.TotalReceived),
		zap.Float64("base_score", baseScore),
		zap.Float64("final_score", finalScore),
		zap.Float64("missing_rate", metrics.MissingRate),
		zap.Float64("abnormal_rate", metrics.AbnormalRate),
		zap.Int("alert_count", metrics.AlertCount),
		zap.Float64("continuity", metrics.ContinuityScore),
	)

	return finalScore
}

// collectDataMetrics 收集数据质量指标
func (s *DataScorer) collectDataMetrics(cabinetID string, duration time.Duration) DataQualityMetrics {
	startTime := time.Now().Add(-duration)
	endTime := time.Now()

	metrics := DataQualityMetrics{}

	// 1. 计算预期数据条数（假设每60秒采集一次，7种传感器）
	expectedSamplesPerSensor := int(duration.Seconds() / 60)
	sensorCount := 7
	metrics.TotalExpected = expectedSamplesPerSensor * sensorCount

	// 2. 查询实际收到的数据条数（sensor_data表没有cabinet_id字段，直接查询所有数据）
	query := `
		SELECT COUNT(*) 
		FROM sensor_data 
		WHERE timestamp >= ? AND timestamp <= ?
	`
	row := s.db.QueryRow(query, startTime, endTime)
	row.Scan(&metrics.TotalReceived)

	// 3. 计算缺失率
	if metrics.TotalExpected > 0 {
		metrics.MissingRate = 1.0 - float64(metrics.TotalReceived)/float64(metrics.TotalExpected)
		if metrics.MissingRate < 0 {
			metrics.MissingRate = 0
		}
	}

	// 4. 计算异常值数量（基于简单的统计方法）
	metrics.AbnormalCount = s.countAbnormalValues(startTime, endTime)
	if metrics.TotalReceived > 0 {
		metrics.AbnormalRate = float64(metrics.AbnormalCount) / float64(metrics.TotalReceived)
	}

	// 5. 查询告警数量
	alertQuery := `
		SELECT COUNT(*) 
		FROM alerts 
		WHERE timestamp >= ? AND timestamp <= ?
	`
	row = s.db.QueryRow(alertQuery, startTime, endTime)
	row.Scan(&metrics.AlertCount)

	// 6. 计算连续性评分
	metrics.ContinuityScore = s.calculateContinuity(startTime, endTime)

	return metrics
}

// countAbnormalValues 统计异常值数量
func (s *DataScorer) countAbnormalValues(startTime, endTime time.Time) int {
	// 查询每种传感器类型的统计数据
	query := `
		SELECT sensor_type, AVG(value) as avg_val
		FROM sensor_data
		WHERE timestamp >= ? AND timestamp <= ?
		GROUP BY sensor_type
	`

	rows, err := s.db.Query(query, startTime, endTime)
	if err != nil {
		s.logger.Error("查询传感器统计失败", zap.Error(err))
		return 0
	}
	defer rows.Close()

	totalAbnormal := 0

	for rows.Next() {
		var sensorType string
		var avgVal float64

		if err := rows.Scan(&sensorType, &avgVal); err != nil {
			continue
		}

		// 计算该传感器类型的方差
		varianceQuery := `
			SELECT AVG((value - ?) * (value - ?))
			FROM sensor_data
			WHERE sensor_type = ? AND timestamp >= ? AND timestamp <= ?
		`
		var variance sql.NullFloat64
		err := s.db.QueryRow(varianceQuery, avgVal, avgVal, sensorType, startTime, endTime).Scan(&variance)
		if err != nil || !variance.Valid {
			continue
		}

		stdDev := math.Sqrt(variance.Float64)

		// 查询超出 ±3σ 的数据点
		abnormalQuery := `
			SELECT COUNT(*) 
			FROM sensor_data 
			WHERE sensor_type = ? 
			  AND timestamp >= ? AND timestamp <= ?
			  AND (value < ? OR value > ?)
		`

		lowerBound := avgVal - 3*stdDev
		upperBound := avgVal + 3*stdDev

		var count int
		row := s.db.QueryRow(abnormalQuery, sensorType, startTime, endTime, lowerBound, upperBound)
		row.Scan(&count)

		totalAbnormal += count
	}

	return totalAbnormal
}

// calculateContinuity 计算数据连续性评分
func (s *DataScorer) calculateContinuity(startTime, endTime time.Time) float64 {
	// 查询数据点的时间戳，计算时间间隔
	query := `
		SELECT timestamp 
		FROM sensor_data 
		WHERE timestamp >= ? AND timestamp <= ?
		ORDER BY timestamp
	`

	rows, err := s.db.Query(query, startTime, endTime)
	if err != nil {
		s.logger.Error("查询数据连续性失败", zap.Error(err))
		return 1.0 // 默认满分
	}
	defer rows.Close()

	var timestamps []time.Time
	for rows.Next() {
		var t time.Time
		if err := rows.Scan(&t); err != nil {
			continue
		}
		timestamps = append(timestamps, t)
	}

	if len(timestamps) < 2 {
		return 1.0 // 数据点太少，默认满分
	}

	// 计算平均间隔和间隔标准差
	intervals := []float64{}
	for i := 1; i < len(timestamps); i++ {
		interval := timestamps[i].Sub(timestamps[i-1]).Seconds()
		intervals = append(intervals, interval)
	}

	// 计算平均间隔
	var sumInterval float64
	for _, interval := range intervals {
		sumInterval += interval
	}
	avgInterval := sumInterval / float64(len(intervals))

	// 计算标准差
	var sumSquaredDiff float64
	for _, interval := range intervals {
		diff := interval - avgInterval
		sumSquaredDiff += diff * diff
	}
	stdDev := math.Sqrt(sumSquaredDiff / float64(len(intervals)))

	// 连续性评分：标准差越小越好
	// 如果标准差 < 平均间隔的10%，认为非常连续(评分1.0)
	// 如果标准差 > 平均间隔的50%，认为很不连续(评分0.5)
	if avgInterval == 0 {
		return 1.0
	}

	relativeDev := stdDev / avgInterval
	if relativeDev < 0.1 {
		return 1.0
	} else if relativeDev > 0.5 {
		return 0.5
	} else {
		// 线性插值
		return 1.0 - (relativeDev-0.1)/0.4*0.5
	}
}

// GetDataQualityMetrics 获取数据质量指标（供外部查询）
func (s *DataScorer) GetDataQualityMetrics(cabinetID string, duration time.Duration) DataQualityMetrics {
	return s.collectDataMetrics(cabinetID, duration)
}
