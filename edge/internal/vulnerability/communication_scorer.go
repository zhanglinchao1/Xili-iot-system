/*
 * 通信异常评分模块
 * 基于传输指标计算通信质量评分
 */
package vulnerability

import (
	"math"
	"sync"
	"time"

	"github.com/edge/storage-cabinet/pkg/models"
	"go.uber.org/zap"
)

// CommunicationScorer 通信评分器
type CommunicationScorer struct {
	logger *zap.Logger
	config VulnerabilityConfig

	// 统计数据
	stats      *CommunicationStats
	statsMutex sync.RWMutex
}

// CommunicationStats 通信统计数据
type CommunicationStats struct {
	// MQTT连接统计
	MQTTConnected      bool
	LastConnectTime    time.Time
	LastDisconnectTime time.Time
	ReconnectionCount  int

	// 消息统计
	MessagesSent     int64
	MessagesReceived int64
	MessagesFailed   int64
	LastMessageTime  time.Time

	// 性能统计
	AvgLatency     float64
	MaxLatency     float64
	MinLatency     float64
	LatencySamples int

	// 统计窗口
	WindowStartTime time.Time
}

// NewCommunicationScorer 创建通信评分器
func NewCommunicationScorer(cfg VulnerabilityConfig, logger *zap.Logger) *CommunicationScorer {
	return &CommunicationScorer{
		logger: logger,
		config: cfg,
		stats: &CommunicationStats{
			WindowStartTime: time.Now(),
		},
	}
}

// CollectMetrics 收集传输指标
func (s *CommunicationScorer) CollectMetrics() *models.TransmissionMetrics {
	s.statsMutex.RLock()
	defer s.statsMutex.RUnlock()

	// 计算时间窗口
	windowDuration := time.Since(s.stats.WindowStartTime)
	if windowDuration == 0 {
		windowDuration = 1 * time.Second // 避免除零
	}

	// 计算丢包率
	totalMessages := s.stats.MessagesSent
	failedMessages := s.stats.MessagesFailed
	var packetLossRate float64
	if totalMessages > 0 {
		packetLossRate = float64(failedMessages) / float64(totalMessages)
	}

	// 计算MQTT成功率
	var mqttSuccessRate float64
	if totalMessages > 0 {
		mqttSuccessRate = float64(totalMessages-failedMessages) / float64(totalMessages)
	} else {
		mqttSuccessRate = 1.0 // 没有数据时默认100%
	}

	// 计算吞吐量 (消息/秒转换为Kbps，假设每条消息平均1KB)
	throughput := float64(s.stats.MessagesSent) / windowDuration.Seconds() * 8.0 // Kbps

	// 计算每小时重连次数
	reconnectPerHour := float64(s.stats.ReconnectionCount) / windowDuration.Hours()
	if windowDuration.Hours() < 1 {
		reconnectPerHour = float64(s.stats.ReconnectionCount) // 不满1小时按实际值
	}

	return &models.TransmissionMetrics{
		LatencyAvg:        s.stats.AvgLatency,
		PacketLossRate:    packetLossRate,
		Throughput:        throughput,
		MQTTSuccessRate:   mqttSuccessRate,
		ReconnectionCount: int(reconnectPerHour),
	}
}

// CalculateScore 计算通信评分
func (s *CommunicationScorer) CalculateScore(metrics *models.TransmissionMetrics) float64 {
	// 权重配置
	w1 := 0.3 // 丢包率权重
	w2 := 0.3 // 延迟权重
	w3 := 0.3 // MQTT成功率权重
	w4 := 0.1 // 稳定性权重

	// 检查数据有效性
	hasData := metrics != nil && (metrics.LatencyAvg > 0 || metrics.PacketLossRate >= 0 || metrics.MQTTSuccessRate > 0)
	
	// 1. 丢包率评分 (0-100)
	var lossScore float64
	if metrics == nil || metrics.PacketLossRate < 0 {
		// 没有数据时，给予高分（假设无丢包）
		lossScore = 100.0
	} else {
		lossScore = (1.0 - metrics.PacketLossRate) * 100.0
		if lossScore < 0 {
			lossScore = 0
		}
		if lossScore > 100 {
			lossScore = 100
		}
	}

	// 2. 延迟评分 (0-100)
	latencyThreshold := s.config.Communication.LatencyThresholdMs
	if latencyThreshold <= 0 {
		latencyThreshold = 2000 // 默认2000ms
	}
	
	var latencyScore float64
	if metrics == nil || metrics.LatencyAvg <= 0 {
		// 没有延迟数据时，给予高分（假设延迟很低）
		latencyScore = 100.0
	} else {
		// 使用更友好的评分曲线：内网环境延迟一般很低，即使100ms也应该给高分
		// 0-100ms: 100分
		// 100-500ms: 线性从100降到85分
		// 500-2000ms: 线性从85降到60分
		// >2000ms: 指数衰减,最低30分
		if metrics.LatencyAvg <= 100 {
			latencyScore = 100.0
		} else if metrics.LatencyAvg <= 500 {
			// 100-500ms: 100 → 90
			ratio := (metrics.LatencyAvg - 100) / 400
			latencyScore = 100.0 - ratio*10.0
		} else if metrics.LatencyAvg <= latencyThreshold {
			// 500-2000ms: 90 → 70
			ratio := (metrics.LatencyAvg - 500) / (latencyThreshold - 500)
			latencyScore = 90.0 - ratio*20.0
		} else {
			// >2000ms: 指数衰减
			ratio := metrics.LatencyAvg / latencyThreshold
			latencyScore = 70.0 * math.Exp(-(ratio-1.0))
			if latencyScore < 30 {
				latencyScore = 30 // 最低30分
			}
		}
	}

	// 3. MQTT成功率评分 (0-100)
	var mqttScore float64
	if metrics == nil || metrics.MQTTSuccessRate <= 0 {
		// 没有数据时，给予高分（假设100%成功）
		mqttScore = 100.0
	} else {
		mqttScore = metrics.MQTTSuccessRate * 100.0
	}

	// 4. 稳定性评分 (0-100)
	// 稳定性系数 = 1 / (1 + 重连次数/阈值)
	reconnectThreshold := float64(s.config.Communication.ReconnectThresholdPerHour)
	if reconnectThreshold <= 0 {
		reconnectThreshold = 10
	}
	
	var stabilityScore float64
	if metrics == nil {
		// 没有数据时，给予高分（假设稳定）
		stabilityScore = 100.0
	} else {
		// 优化稳定性评分：0次重连100分，1-3次重连95分，>10次按原公式
		if metrics.ReconnectionCount == 0 {
			stabilityScore = 100.0
		} else if metrics.ReconnectionCount <= 3 {
			stabilityScore = 100.0 - float64(metrics.ReconnectionCount)*1.5 // 每次扣1.5分
		} else {
			stabilityCoefficient := 1.0 / (1.0 + float64(metrics.ReconnectionCount)/reconnectThreshold)
			stabilityScore = stabilityCoefficient * 100.0
			// 确保最低70分
			if stabilityScore < 70 {
				stabilityScore = 70
			}
		}
	}

	// 加权平均
	baseScore := w1*lossScore + w2*latencyScore + w3*mqttScore + w4*stabilityScore

	// 确保基础评分在0-100范围内
	if baseScore < 0 {
		baseScore = 0
	}
	if baseScore > 100 {
		baseScore = 100
	}

	// 如果没有有效数据，给予高分（98分），避免因数据不足导致评分过低
	if !hasData {
		baseScore = 98.0
		s.logger.Warn("通信评分：无有效数据，使用默认分数98分")
	}

	// 直接使用baseScore作为最终分数
	finalScore := baseScore

	s.logger.Info("计算通信评分",
		zap.Bool("has_data", hasData),
		zap.Float64("loss_score", lossScore),
		zap.Float64("latency_score", latencyScore),
		zap.Float64("mqtt_score", mqttScore),
		zap.Float64("stability_score", stabilityScore),
		zap.Float64("base_score", baseScore),
		zap.Float64("final_score", finalScore),
		zap.Float64("latency_avg", func() float64 {
			if metrics != nil {
				return metrics.LatencyAvg
			}
			return 0
		}()),
		zap.Float64("packet_loss_rate", func() float64 {
			if metrics != nil {
				return metrics.PacketLossRate
			}
			return 0
		}()),
		zap.Float64("mqtt_success_rate", func() float64 {
			if metrics != nil {
				return metrics.MQTTSuccessRate
			}
			return 0
		}()),
		zap.Int("reconnection_count", func() int {
			if metrics != nil {
				return metrics.ReconnectionCount
			}
			return 0
		}()),
	)

	return finalScore
}

// RecordConnection MQTT连接事件
func (s *CommunicationScorer) RecordConnection() {
	s.statsMutex.Lock()
	defer s.statsMutex.Unlock()

	s.stats.MQTTConnected = true
	s.stats.LastConnectTime = time.Now()
}

// RecordDisconnection MQTT断连事件
func (s *CommunicationScorer) RecordDisconnection() {
	s.statsMutex.Lock()
	defer s.statsMutex.Unlock()

	s.stats.MQTTConnected = false
	s.stats.LastDisconnectTime = time.Now()
	s.stats.ReconnectionCount++
}

// RecordMessageSent 记录消息发送
func (s *CommunicationScorer) RecordMessageSent() {
	s.statsMutex.Lock()
	defer s.statsMutex.Unlock()

	s.stats.MessagesSent++
	s.stats.LastMessageTime = time.Now()
}

// RecordMessageReceived 记录消息接收
func (s *CommunicationScorer) RecordMessageReceived(latency float64) {
	s.statsMutex.Lock()
	defer s.statsMutex.Unlock()

	s.stats.MessagesReceived++
	s.stats.LastMessageTime = time.Now()

	// 更新延迟统计
	if s.stats.LatencySamples == 0 {
		s.stats.AvgLatency = latency
		s.stats.MinLatency = latency
		s.stats.MaxLatency = latency
	} else {
		// 计算移动平均
		s.stats.AvgLatency = (s.stats.AvgLatency*float64(s.stats.LatencySamples) + latency) / float64(s.stats.LatencySamples+1)

		if latency < s.stats.MinLatency {
			s.stats.MinLatency = latency
		}
		if latency > s.stats.MaxLatency {
			s.stats.MaxLatency = latency
		}
	}
	s.stats.LatencySamples++
}

// RecordMessageFailed 记录消息失败
func (s *CommunicationScorer) RecordMessageFailed() {
	s.statsMutex.Lock()
	defer s.statsMutex.Unlock()

	s.stats.MessagesFailed++
}

// ResetWindow 重置统计窗口
func (s *CommunicationScorer) ResetWindow() {
	s.statsMutex.Lock()
	defer s.statsMutex.Unlock()

	s.stats = &CommunicationStats{
		MQTTConnected:   s.stats.MQTTConnected,
		WindowStartTime: time.Now(),
	}
}

// GetStats 获取当前统计数据
func (s *CommunicationScorer) GetStats() CommunicationStats {
	s.statsMutex.RLock()
	defer s.statsMutex.RUnlock()

	return *s.stats
}
