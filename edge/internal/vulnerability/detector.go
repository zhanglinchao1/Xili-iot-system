/*
 * 轻量级漏洞检测规则引擎
 * 基于规则检测潜在安全漏洞
 */
package vulnerability

import (
	"database/sql"
	"os"
	"time"

	"github.com/edge/storage-cabinet/pkg/models"
	"go.uber.org/zap"
)

// Detector 漏洞检测器
type Detector struct {
	logger *zap.Logger
	config VulnerabilityConfig
	db     *sql.DB
}

// NewDetector 创建漏洞检测器
func NewDetector(cfg VulnerabilityConfig, db *sql.DB, logger *zap.Logger) *Detector {
	return &Detector{
		logger: logger,
		config: cfg,
		db:     db,
	}
}

// DetectVulnerabilities 检测漏洞
func (d *Detector) DetectVulnerabilities(cabinetID string) []models.VulnerabilityEvent {
	vulnerabilities := []models.VulnerabilityEvent{}
	
	// 1. 检测端口扫描攻击
	if vuln := d.detectPortScan(); vuln != nil {
		vulnerabilities = append(vulnerabilities, *vuln)
	}
	
	// 2. 检测数据频率异常
	if vuln := d.detectFrequencyAnomaly(cabinetID); vuln != nil {
		vulnerabilities = append(vulnerabilities, *vuln)
	}
	
	// 3. 检测配置篡改
	if vuln := d.detectConfigTampering(); vuln != nil {
		vulnerabilities = append(vulnerabilities, *vuln)
	}
	
	// 4. 检测存储告警
	if vuln := d.detectStorageIssue(); vuln != nil {
		vulnerabilities = append(vulnerabilities, *vuln)
	}
	
	d.logger.Debug("漏洞检测完成",
		zap.Int("count", len(vulnerabilities)),
	)
	
	return vulnerabilities
}

// detectPortScan 检测端口扫描攻击
func (d *Detector) detectPortScan() *models.VulnerabilityEvent {
	// 查询最近10分钟内的认证失败次数
	query := `
		SELECT COUNT(*) 
		FROM system_logs 
		WHERE level = 'error' 
		  AND module = 'auth' 
		  AND message LIKE '%认证失败%'
		  AND timestamp >= datetime('now', '-10 minutes')
	`
	
	var failedCount int
	row := d.db.QueryRow(query)
	if err := row.Scan(&failedCount); err != nil {
		return nil
	}
	
	// 如果10分钟内失败次数超过10次，可能是扫描攻击
	if failedCount > 10 {
		return &models.VulnerabilityEvent{
			Type:        "port_scan",
			Category:    "network",
			Title:       "疑似端口扫描攻击",
			Severity:    "medium",
			Description: "检测到短时间内多次认证失败，可能存在端口扫描或暴力破解攻击",
			Solution:    "建议检查防火墙配置，限制非授权IP访问，并考虑启用IP白名单机制",
			DetectedAt:  time.Now(),
		}
	}
	
	return nil
}

// detectFrequencyAnomaly 检测数据频率异常
func (d *Detector) detectFrequencyAnomaly(cabinetID string) *models.VulnerabilityEvent {
	// 查询最近10分钟和前10分钟的数据量（包括传感器数据和心跳数据）
	now := time.Now()
	recent10min := now.Add(-10 * time.Minute)
	previous10min := recent10min.Add(-10 * time.Minute)
	
	var recentSensorCount, previousSensorCount int
	var recentHeartbeatCount, previousHeartbeatCount int
	
	// 最近10分钟的传感器数据
	sensorQuery := `SELECT COUNT(*) FROM sensor_data WHERE timestamp >= ? AND timestamp < ?`
	row := d.db.QueryRow(sensorQuery, recent10min, now)
	row.Scan(&recentSensorCount)
	
	// 前10分钟的传感器数据
	row = d.db.QueryRow(sensorQuery, previous10min, recent10min)
	row.Scan(&previousSensorCount)
	
	// 最近10分钟的心跳数据（通过devices表的last_seen统计）
	// 心跳频率：每60秒一次，10分钟内预期有10次心跳/设备
	heartbeatQuery := `SELECT COUNT(*) FROM devices WHERE last_seen >= ? AND last_seen < ?`
	row = d.db.QueryRow(heartbeatQuery, recent10min, now)
	row.Scan(&recentHeartbeatCount)
	
	// 前10分钟的心跳数据
	row = d.db.QueryRow(heartbeatQuery, previous10min, recent10min)
	row.Scan(&previousHeartbeatCount)
	
	// 计算总数据量（传感器数据 + 心跳数据）
	recentTotal := recentSensorCount + recentHeartbeatCount
	previousTotal := previousSensorCount + previousHeartbeatCount
	
	// 改进：需要有足够的历史数据才能判断异常
	// 如果历史数据过少（<50条），或最近数据也很少（<50条），则跳过检测
	if previousTotal < 50 || recentTotal < 50 {
		d.logger.Debug("频率异常检测：数据量不足，跳过检测",
			zap.Int("recent_total", recentTotal),
			zap.Int("previous_total", previousTotal),
		)
		return nil // 数据不足，无法准确判断
	}

	// 计算变化率
	changeRate := float64(recentTotal-previousTotal) / float64(previousTotal)

	d.logger.Debug("频率异常检测",
		zap.Int("recent_sensor", recentSensorCount),
		zap.Int("recent_heartbeat", recentHeartbeatCount),
		zap.Int("recent_total", recentTotal),
		zap.Int("previous_total", previousTotal),
		zap.Float64("change_rate", changeRate),
	)

	// 如果突增超过200%（进一步提高阈值，避免正常波动被误报）
	if changeRate > 2.0 {
		return &models.VulnerabilityEvent{
			Type:        "frequency_spike",
			Category:    "data",
			Title:       "数据频率异常突增",
			Severity:    "low",
			Description: "数据上报频率异常突增，可能存在异常数据注入",
			Solution:    "检查传感器设备是否工作正常，确认是否有未授权设备接入系统",
			DetectedAt:  time.Now(),
		}
	}
	
	// 如果骤降超过70%（考虑心跳数据后，正常情况不会骤降超过70%）
	if changeRate < -0.7 {
		return &models.VulnerabilityEvent{
			Type:        "frequency_drop",
			Category:    "network",
			Title:       "数据频率异常骤降",
			Severity:    "medium",
			Description: "数据上报频率异常骤降，可能存在拒绝服务攻击或设备故障",
			Solution:    "检查网络连接状态和MQTT服务是否正常，排查是否存在DoS攻击",
			DetectedAt:  time.Now(),
		}
	}
	
	return nil
}

// detectConfigTampering 检测配置篡改
func (d *Detector) detectConfigTampering() *models.VulnerabilityEvent {
	configPath := "./configs/config.yaml"
	
	fileInfo, err := os.Stat(configPath)
	if err != nil {
		return nil
	}
	
	modTime := fileInfo.ModTime()
	
	// 如果配置文件在最近1小时内被修改
	if time.Since(modTime) < 1*time.Hour {
		return &models.VulnerabilityEvent{
			Type:        "config_tampering",
			Category:    "config",
			Title:       "配置文件被篡改",
			Severity:    "high",
			Description: "检测到关键配置文件最近被修改，请确认是否为授权操作",
			Solution:    "确认修改是否为授权操作，如非授权修改请立即回滚并检查系统日志排查入侵痕迹",
			DetectedAt:  time.Now(),
		}
	}
	
	return nil
}

// detectStorageIssue 检测存储告警
func (d *Detector) detectStorageIssue() *models.VulnerabilityEvent {
	dbPath := "./data/edge.db"
	
	// 获取数据库文件大小
	fileInfo, err := os.Stat(dbPath)
	if err != nil {
		return nil
	}
	
	dbSize := fileInfo.Size()
	
	// 获取磁盘可用空间（简化版，实际需要syscall）
	// 这里暂时只检查数据库文件大小
	maxDBSize := int64(100 * 1024 * 1024) // 100MB
	
	if dbSize > maxDBSize {
		return &models.VulnerabilityEvent{
			Type:        "storage_warning",
			Category:    "config",
			Title:       "存储空间告警",
			Severity:    "medium",
			Description: "数据库文件大小超过阈值，建议清理历史数据或扩展存储",
			Solution:    "执行数据清理任务或增加存储容量，可通过 /api/v1/storage/clean 接口清理历史数据",
			DetectedAt:  time.Now(),
		}
	}
	
	// 检查磁盘使用率（需要实现获取磁盘空间的逻辑）
	diskUsage := d.getDiskUsage()
	if diskUsage > 0.9 {
		return &models.VulnerabilityEvent{
			Type:        "disk_full",
			Category:    "config",
			Title:       "磁盘空间严重不足",
			Severity:    "critical",
			Description: "磁盘使用率超过90%，系统面临存储空间不足风险",
			Solution:    "立即清理不必要的文件，扩展存储容量，或迁移历史数据到归档存储",
			DetectedAt:  time.Now(),
		}
	}
	
	return nil
}

// getDiskUsage 获取磁盘使用率（简化版）
func (d *Detector) getDiskUsage() float64 {
	// TODO: 实现获取实际磁盘使用率的逻辑
	// 这里返回一个模拟值
	return 0.5 // 50%
}

