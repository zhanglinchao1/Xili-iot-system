package postgres

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"cloud-system/internal/models"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"go.uber.org/zap"
)

// VulnerabilityRepository PostgreSQL实现
type VulnerabilityRepository struct {
	pool   *pgxpool.Pool
	logger *zap.Logger
}

// NewVulnerabilityRepository 创建Repository
func NewVulnerabilityRepository(pool *pgxpool.Pool, logger *zap.Logger) *VulnerabilityRepository {
	return &VulnerabilityRepository{
		pool:   pool,
		logger: logger,
	}
}

// CreateAssessment 创建评估记录
func (r *VulnerabilityRepository) CreateAssessment(ctx context.Context, assessment *models.VulnerabilityAssessment) (int64, error) {
	query := `
		INSERT INTO vulnerability_assessments (
			cabinet_id, timestamp,
			license_compliance_score, communication_score,
			config_security_score, data_anomaly_score,
			overall_score, risk_level,
			transmission_metrics, traffic_features,
			config_checks, detected_vulnerabilities,
			synced_from_edge, received_at
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
		) RETURNING id
	`

	var id int64
	err := r.pool.QueryRow(
		ctx, query,
		assessment.CabinetID,
		assessment.Timestamp,
		assessment.LicenseComplianceScore,
		assessment.CommunicationScore,
		assessment.ConfigSecurityScore,
		assessment.DataAnomalyScore,
		assessment.OverallScore,
		assessment.RiskLevel,
		assessment.TransmissionMetrics,
		assessment.TrafficFeatures,
		assessment.ConfigChecks,
		assessment.DetectedVulnerabilities,
		assessment.SyncedFromEdge,
		assessment.ReceivedAt,
	).Scan(&id)

	if err != nil {
		r.logger.Error("创建评估记录失败", zap.Error(err))
		return 0, err
	}

	r.logger.Info("创建评估记录成功",
		zap.Int64("id", id),
		zap.String("cabinet_id", assessment.CabinetID),
		zap.Float64("overall_score", assessment.OverallScore),
	)

	return id, nil
}

// CreateEvents 批量创建漏洞事件
func (r *VulnerabilityRepository) CreateEvents(ctx context.Context, events []*models.VulnerabilityEvent) error {
	if len(events) == 0 {
		return nil
	}

	tx, err := r.pool.Begin(ctx)
	if err != nil {
		return err
	}
	defer tx.Rollback(ctx)

	query := `
		INSERT INTO vulnerability_events (
			assessment_id, cabinet_id, event_type, category,
			title, severity, description, solution, detected_at
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
	`

	for _, event := range events {
		_, err := tx.Exec(
			ctx, query,
			event.AssessmentID,
			event.CabinetID,
			event.EventType,
			event.Category,
			event.Title,
			event.Severity,
			event.Description,
			event.Solution,
			event.DetectedAt,
		)
		if err != nil {
			r.logger.Error("创建事件失败", zap.Error(err))
			return err
		}
	}

	if err := tx.Commit(ctx); err != nil {
		r.logger.Error("提交事务失败", zap.Error(err))
		return err
	}

	r.logger.Info("批量创建事件成功", zap.Int("count", len(events)))
	return nil
}

// GetLatestByCabinetID 获取储能柜最新评估
func (r *VulnerabilityRepository) GetLatestByCabinetID(ctx context.Context, cabinetID string) (*models.VulnerabilityAssessment, error) {
	query := `
		SELECT id, cabinet_id, timestamp,
			license_compliance_score, communication_score,
			config_security_score, data_anomaly_score,
			overall_score, risk_level,
			transmission_metrics, traffic_features,
			config_checks, detected_vulnerabilities,
			synced_from_edge, received_at
		FROM vulnerability_assessments
		WHERE cabinet_id = $1
		ORDER BY timestamp DESC
		LIMIT 1
	`

	var assessment models.VulnerabilityAssessment
	err := r.pool.QueryRow(ctx, query, cabinetID).Scan(
		&assessment.ID,
		&assessment.CabinetID,
		&assessment.Timestamp,
		&assessment.LicenseComplianceScore,
		&assessment.CommunicationScore,
		&assessment.ConfigSecurityScore,
		&assessment.DataAnomalyScore,
		&assessment.OverallScore,
		&assessment.RiskLevel,
		&assessment.TransmissionMetrics,
		&assessment.TrafficFeatures,
		&assessment.ConfigChecks,
		&assessment.DetectedVulnerabilities,
		&assessment.SyncedFromEdge,
		&assessment.ReceivedAt,
	)
	if err == pgx.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		r.logger.Error("获取最新评估失败", zap.Error(err))
		return nil, err
	}

	return &assessment, nil
}

// GetAssessmentByID 根据ID获取评估
func (r *VulnerabilityRepository) GetAssessmentByID(ctx context.Context, id int64) (*models.VulnerabilityAssessment, error) {
	query := `
		SELECT id, cabinet_id, timestamp,
			license_compliance_score, communication_score,
			config_security_score, data_anomaly_score,
			overall_score, risk_level,
			transmission_metrics, traffic_features,
			config_checks, detected_vulnerabilities,
			synced_from_edge, received_at
		FROM vulnerability_assessments
		WHERE id = $1
	`

	var assessment models.VulnerabilityAssessment
	err := r.pool.QueryRow(ctx, query, id).Scan(
		&assessment.ID,
		&assessment.CabinetID,
		&assessment.Timestamp,
		&assessment.LicenseComplianceScore,
		&assessment.CommunicationScore,
		&assessment.ConfigSecurityScore,
		&assessment.DataAnomalyScore,
		&assessment.OverallScore,
		&assessment.RiskLevel,
		&assessment.TransmissionMetrics,
		&assessment.TrafficFeatures,
		&assessment.ConfigChecks,
		&assessment.DetectedVulnerabilities,
		&assessment.SyncedFromEdge,
		&assessment.ReceivedAt,
	)
	if err == pgx.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		r.logger.Error("获取评估失败", zap.Error(err))
		return nil, err
	}

	return &assessment, nil
}

// GetEventsByAssessmentID 获取评估的所有漏洞事件
func (r *VulnerabilityRepository) GetEventsByAssessmentID(ctx context.Context, assessmentID int64) ([]*models.VulnerabilityEvent, error) {
	query := `
		SELECT id, assessment_id, cabinet_id, event_type, category,
			title, severity, description, solution, detected_at, created_at
		FROM vulnerability_events
		WHERE assessment_id = $1
		ORDER BY severity DESC, detected_at DESC
	`

	rows, err := r.pool.Query(ctx, query, assessmentID)
	if err != nil {
		r.logger.Error("获取事件失败", zap.Error(err))
		return nil, err
	}
	defer rows.Close()

	var events []*models.VulnerabilityEvent
	for rows.Next() {
		event := &models.VulnerabilityEvent{}
		err := rows.Scan(
			&event.ID,
			&event.AssessmentID,
			&event.CabinetID,
			&event.EventType,
			&event.Category,
			&event.Title,
			&event.Severity,
			&event.Description,
			&event.Solution,
			&event.DetectedAt,
			&event.CreatedAt,
		)
		if err != nil {
			r.logger.Error("扫描事件数据失败", zap.Error(err))
			return nil, err
		}
		events = append(events, event)
	}

	if err := rows.Err(); err != nil {
		r.logger.Error("遍历事件数据失败", zap.Error(err))
		return nil, err
	}

	return events, nil
}

// ListAssessments 分页查询评估记录
func (r *VulnerabilityRepository) ListAssessments(ctx context.Context, query *models.VulnerabilityListQuery) ([]*models.VulnerabilityAssessment, int64, error) {
	// 构建查询条件
	whereClause := "WHERE 1=1"
	args := []interface{}{}
	argIndex := 1

	if query.CabinetID != "" {
		whereClause += fmt.Sprintf(" AND cabinet_id = $%d", argIndex)
		args = append(args, query.CabinetID)
		argIndex++
	}

	if !query.StartTime.IsZero() {
		whereClause += fmt.Sprintf(" AND timestamp >= $%d", argIndex)
		args = append(args, query.StartTime)
		argIndex++
	}

	if !query.EndTime.IsZero() {
		whereClause += fmt.Sprintf(" AND timestamp <= $%d", argIndex)
		args = append(args, query.EndTime)
		argIndex++
	}

	if query.RiskLevel != "" {
		whereClause += fmt.Sprintf(" AND risk_level = $%d", argIndex)
		args = append(args, query.RiskLevel)
		argIndex++
	}

	// 查询总数
	countQuery := "SELECT COUNT(*) FROM vulnerability_assessments " + whereClause
	var total int64
	err := r.pool.QueryRow(ctx, countQuery, args...).Scan(&total)
	if err != nil {
		r.logger.Error("查询总数失败", zap.Error(err))
		return nil, 0, err
	}

	// 分页参数
	if query.Page <= 0 {
		query.Page = 1
	}
	if query.PageSize <= 0 {
		query.PageSize = 20
	}
	offset := (query.Page - 1) * query.PageSize

	// 查询数据
	dataQuery := fmt.Sprintf(`
		SELECT id, cabinet_id, timestamp,
			license_compliance_score, communication_score,
			config_security_score, data_anomaly_score,
			overall_score, risk_level,
			transmission_metrics, traffic_features,
			config_checks, detected_vulnerabilities,
			synced_from_edge, received_at
		FROM vulnerability_assessments
		%s
		ORDER BY timestamp DESC
		LIMIT $%d OFFSET $%d
	`, whereClause, argIndex, argIndex+1)

	args = append(args, query.PageSize, offset)

	rows, err := r.pool.Query(ctx, dataQuery, args...)
	if err != nil {
		r.logger.Error("查询评估列表失败", zap.Error(err))
		return nil, 0, err
	}
	defer rows.Close()

	var assessments []*models.VulnerabilityAssessment
	for rows.Next() {
		assessment := &models.VulnerabilityAssessment{}
		err := rows.Scan(
			&assessment.ID,
			&assessment.CabinetID,
			&assessment.Timestamp,
			&assessment.LicenseComplianceScore,
			&assessment.CommunicationScore,
			&assessment.ConfigSecurityScore,
			&assessment.DataAnomalyScore,
			&assessment.OverallScore,
			&assessment.RiskLevel,
			&assessment.TransmissionMetrics,
			&assessment.TrafficFeatures,
			&assessment.ConfigChecks,
			&assessment.DetectedVulnerabilities,
			&assessment.SyncedFromEdge,
			&assessment.ReceivedAt,
		)
		if err != nil {
			r.logger.Error("扫描评估数据失败", zap.Error(err))
			return nil, 0, err
		}
		assessments = append(assessments, assessment)
	}

	if err := rows.Err(); err != nil {
		r.logger.Error("遍历评估数据失败", zap.Error(err))
		return nil, 0, err
	}

	return assessments, total, nil
}

// GetHistoryByCabinetID 获取储能柜历史评估
func (r *VulnerabilityRepository) GetHistoryByCabinetID(ctx context.Context, cabinetID string, startTime, endTime time.Time, limit int) ([]*models.VulnerabilityAssessment, error) {
	if limit <= 0 {
		limit = 100
	}

	query := `
		SELECT id, cabinet_id, timestamp,
			license_compliance_score, communication_score,
			config_security_score, data_anomaly_score,
			overall_score, risk_level,
			transmission_metrics, traffic_features,
			config_checks, detected_vulnerabilities,
			synced_from_edge, received_at
		FROM vulnerability_assessments
		WHERE cabinet_id = $1
			AND timestamp >= $2
			AND timestamp <= $3
		ORDER BY timestamp DESC
		LIMIT $4
	`

	rows, err := r.pool.Query(ctx, query, cabinetID, startTime, endTime, limit)
	if err != nil {
		r.logger.Error("获取历史评估失败", zap.Error(err))
		return nil, err
	}
	defer rows.Close()

	var assessments []*models.VulnerabilityAssessment
	for rows.Next() {
		assessment := &models.VulnerabilityAssessment{}
		err := rows.Scan(
			&assessment.ID,
			&assessment.CabinetID,
			&assessment.Timestamp,
			&assessment.LicenseComplianceScore,
			&assessment.CommunicationScore,
			&assessment.ConfigSecurityScore,
			&assessment.DataAnomalyScore,
			&assessment.OverallScore,
			&assessment.RiskLevel,
			&assessment.TransmissionMetrics,
			&assessment.TrafficFeatures,
			&assessment.ConfigChecks,
			&assessment.DetectedVulnerabilities,
			&assessment.SyncedFromEdge,
			&assessment.ReceivedAt,
		)
		if err != nil {
			r.logger.Error("扫描历史评估数据失败", zap.Error(err))
			return nil, err
		}
		assessments = append(assessments, assessment)
	}

	if err := rows.Err(); err != nil {
		r.logger.Error("遍历历史评估数据失败", zap.Error(err))
		return nil, err
	}

	return assessments, nil
}

// DeleteOldAssessments 删除旧评估数据
func (r *VulnerabilityRepository) DeleteOldAssessments(ctx context.Context, beforeTime time.Time) error {
	query := `DELETE FROM vulnerability_assessments WHERE timestamp < $1`

	result, err := r.pool.Exec(ctx, query, beforeTime)
	if err != nil {
		r.logger.Error("删除旧数据失败", zap.Error(err))
		return err
	}

	affected := result.RowsAffected()
	r.logger.Info("删除旧评估数据",
		zap.Int64("affected", affected),
		zap.Time("before", beforeTime),
	)

	return nil
}

// GetStatsByCabinetID 获取储能柜评估统计
func (r *VulnerabilityRepository) GetStatsByCabinetID(ctx context.Context, cabinetID string, days int) (map[string]interface{}, error) {
	startTime := time.Now().AddDate(0, 0, -days)

	query := `
		SELECT
			COUNT(*) as total_assessments,
			AVG(overall_score) as avg_score,
			MIN(overall_score) as min_score,
			MAX(overall_score) as max_score,
			COUNT(CASE WHEN risk_level = 'critical' THEN 1 END) as critical_count,
			COUNT(CASE WHEN risk_level = 'high' THEN 1 END) as high_count,
			COUNT(CASE WHEN risk_level = 'medium' THEN 1 END) as medium_count,
			COUNT(CASE WHEN risk_level = 'low' THEN 1 END) as low_count,
			COUNT(CASE WHEN risk_level = 'healthy' THEN 1 END) as healthy_count
		FROM vulnerability_assessments
		WHERE cabinet_id = $1 AND timestamp >= $2
	`

	var stats struct {
		TotalAssessments int
		AvgScore         float64
		MinScore         float64
		MaxScore         float64
		CriticalCount    int
		HighCount        int
		MediumCount      int
		LowCount         int
		HealthyCount     int
	}

	err := r.pool.QueryRow(ctx, query, cabinetID, startTime).Scan(
		&stats.TotalAssessments,
		&stats.AvgScore,
		&stats.MinScore,
		&stats.MaxScore,
		&stats.CriticalCount,
		&stats.HighCount,
		&stats.MediumCount,
		&stats.LowCount,
		&stats.HealthyCount,
	)
	if err != nil {
		r.logger.Error("获取统计数据失败", zap.Error(err))
		return nil, err
	}

	result := map[string]interface{}{
		"total_assessments": stats.TotalAssessments,
		"avg_score":         stats.AvgScore,
		"min_score":         stats.MinScore,
		"max_score":         stats.MaxScore,
		"risk_distribution": map[string]int{
			"critical": stats.CriticalCount,
			"high":     stats.HighCount,
			"medium":   stats.MediumCount,
			"low":      stats.LowCount,
			"healthy":  stats.HealthyCount,
		},
	}

	return result, nil
}

// Helper: 将map转为JSON字符串
func toJSONString(data interface{}) *string {
	if data == nil {
		return nil
	}
	bytes, err := json.Marshal(data)
	if err != nil {
		return nil
	}
	str := string(bytes)
	return &str
}
